import type EventEmitter from "events";

export interface StoryLoadResult {
    rootSelector: string;
    playFunctionError?: string;
    loadError?: string;
}

interface HTMLElement {
    innerText: string;
}

export type StorybookWindow = Window &
    typeof globalThis & {
        __TESTPLANE_STORYBOOK_INITIAL_GLOBALS__?: Record<string, unknown>;
        __STORYBOOK_PREVIEW__?: { storeInitializationPromise?: Promise<void> };
        __STORYBOOK_ADDONS_CHANNEL__: EventEmitter & {
            data?: { setGlobals?: Array<{ globals: Record<string, unknown> }> };
        };
        __STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__: Record<
            string,
            {
                calls: Array<{
                    exception?: {
                        message: string;
                    };
                }>;
            }
        >;
    };

function openStoryScript(
    storyId: string,
    storybookGlobals: Record<string, unknown>,
    shouldRemount: boolean,
    done: (result: string) => void,
): void {
    function onPageLoad(fn: () => void): void {
        if (document.readyState === "complete") {
            fn();
        } else {
            document.onreadystatechange = function () {
                if (document.readyState === "complete") {
                    fn();
                }
            };
        }
    }

    onPageLoad(function () {
        const channel = (window as StorybookWindow).__STORYBOOK_ADDONS_CHANNEL__;
        const result: StoryLoadResult = { rootSelector: "" };

        function doneJson(value: StoryLoadResult): void {
            channel.off("playFunctionThrewException", onPlayFunctionThrewException);
            channel.off("storyRendered", onStoryRendered);
            channel.off("storyMissing", onStoryMissing);
            channel.off("storyThrewException", onStoryThrewException);
            channel.off("storyErrored", onStoryErrored);
            channel.off("globalsUpdated", onGlobalsUpdated);

            done(JSON.stringify(value));
        }

        function onPlayFunctionThrewException(): void {
            result.playFunctionError = "an unknown exception was thrown";
        }

        function onStoryRendered(): void {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            result.rootSelector = ["#storybook-root", "#root"].find(function (selector) {
                return document.querySelector(selector);
            })!;

            if (result.playFunctionError) {
                const instrumenter = (window as StorybookWindow).__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__;
                const storyState = instrumenter ? instrumenter[storyId] : null;
                const storyLastCall =
                    storyState && storyState.calls ? storyState.calls[storyState.calls.length - 1] : null;

                if (storyLastCall && storyLastCall.exception) {
                    result.playFunctionError = storyLastCall.exception.message;
                }
            }

            doneJson(result);
        }

        function onStoryMissing(storyId: string): void {
            if (storyId === "") {
                return;
            }

            const errorMessage = (document.querySelector("#error-stack") as unknown as HTMLElement).innerText;
            const regExpMatch = /\w+:\s+x\s+/.exec(errorMessage);

            if (regExpMatch) {
                result.loadError = errorMessage.slice(regExpMatch[0].length);
            } else {
                result.loadError = errorMessage;
            }

            doneJson(result);
        }

        function onStoryThrewException(exception: Error): void {
            if (exception.message && !exception.message.startsWith("ignoredException")) {
                result.loadError = exception.message;

                doneJson(result);
            }
        }

        function onStoryErrored(error: { title: string }): void {
            result.loadError = error.title;

            doneJson(result);
        }

        function onGlobalsUpdated(): void {
            channel.once("playFunctionThrewException", onPlayFunctionThrewException);
            channel.once("storyRendered", onStoryRendered);
            channel.once("storyMissing", onStoryMissing);
            channel.once("storyThrewException", onStoryThrewException);
            channel.once("storyErrored", onStoryErrored);

            if (shouldRemount) {
                channel.emit("setCurrentStory", { storyId: "" });
            }

            channel.emit("setCurrentStory", { storyId });
        }

        if (!channel) {
            result.loadError = "Couldn't find storybook channel. Looks like the opened page is not storybook preview";

            doneJson(result);
        }

        const storybookPreview = (window as StorybookWindow).__STORYBOOK_PREVIEW__;
        const isStorybookPreviewAvailable = storybookPreview && storybookPreview.storeInitializationPromise;
        const shouldUpdateStorybookGlobals = storybookGlobals && isStorybookPreviewAvailable;

        if (shouldUpdateStorybookGlobals) {
            (storybookPreview.storeInitializationPromise as Promise<void>).then(function () {
                let defaultGlobals = (window as StorybookWindow).__TESTPLANE_STORYBOOK_INITIAL_GLOBALS__;

                if (!defaultGlobals) {
                    const setGlobalCalls = (window as StorybookWindow).__STORYBOOK_ADDONS_CHANNEL__.data?.setGlobals;
                    const initValue = (setGlobalCalls && setGlobalCalls[0].globals) || {};

                    defaultGlobals = (window as StorybookWindow).__TESTPLANE_STORYBOOK_INITIAL_GLOBALS__ = initValue;
                }

                channel.once("globalsUpdated", onGlobalsUpdated);

                channel.emit("updateGlobals", { globals: Object.assign({}, defaultGlobals, storybookGlobals) });
            });
        } else {
            onGlobalsUpdated();
        }
    });
}

export async function execute(
    browser: WebdriverIO.Browser,
    storyId: string,
    storybookGlobals: Record<string, unknown>,
    shouldRemount: boolean,
): Promise<StoryLoadResult> {
    const getResult = ({ disableRemount = false } = {}): Promise<StoryLoadResult> =>
        browser
            .executeAsync(openStoryScript, storyId, storybookGlobals, shouldRemount && !disableRemount)
            .then(JSON.parse);

    return getResult().catch(() => getResult({ disableRemount: true }));
}

export default { execute };
